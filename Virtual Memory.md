# Virtual Memory

为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟存储器（VM）。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：

> * 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
> * 它为每个进程提供了一致的地址空间，从而简化了存储器管理。
> * 它保护了每个进程的地址空间不被其他进程破坏。



### \# 物理和虚拟寻址

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address, PA）。第一个字节的地址为0，接下来的字节地址为1，再下一个为2，依此类推。

给定这种简单的结构，CPU访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为**物理寻址**。

 ![](https://c1.staticflickr.com/8/7649/29092065552_65dd58f97d.jpg)

现代处理器使用的是一种称为**虚拟寻址**的寻址方式，如下图：

 ![](https://c5.staticflickr.com/9/8001/29092065412_be4f4b6185_b.jpg)

CPU 芯片上叫做**存储器管理单元**（Memory Management Unit, MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。



### \# 地址空间

**地址空间**是一个非负整数地址的有序集合：
$$
\{  0, 1, 2, ... \}
$$

> 如果地址空间中的整数是连续的，那么我们说它是一个**线性地址空间**。为了简化讨论，我们总是假设使用的是线性地址空间。



在一个带虚拟存储器的系统中，CPU 从一个有 `N = 2^n` 个地址的地址空间中生成虚拟地址，这个地址空间称为**虚拟地址空间**：
$$
\{ 0, 1, 2, ..., N - 1  \}
$$
一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含`N = 2^n` 个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统典型地支持 32 位或者 64 位虚拟地址空间。



一个系统还有一个**物理地址空间**，它与系统中物理存储器的 *M* 个字节相对应：
$$
\{0, 1, 2, ... , M - 1\}
$$
*M* 不要求是 2 的幂，但是为了简化讨论，我们假设 `M = 2^m`。

**地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。**





### \# 虚拟存储器作为缓存的工具

在任意时刻，虚拟页面的集合都分为三个不相交的子集：

* **未分配的**：VM 系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
* **缓存的**：当前缓存在物理存储器中的已分配页。
* **未缓存的**：没有缓存在物理存储器中的已分配页。

#### 1. DRAM 缓存的组织结构

术语：

* SRAM 缓存：位于 CPU 和 主存之间的 L1、L2 和 L3 高速缓存
* DRAM缓存：表示虚拟存储器系统的缓存，它在主存中缓存虚拟页

归根结底：

DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。

#### 2. 页表

同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判定这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。

这些功能是由许多软硬件联合提供的，包括操作系统软件、MMU（Memory Management Unit）中的地址翻译硬件和一个存放在物理存储器中叫做`页表`（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。

操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。

* 有效位 = 1，地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。
* 有效位 = 0，地址为空，表示这个虚拟页还未被分配。
* 有效位 = 0，地址非空，该地址指向虚拟页在 **磁盘** 上的起始位置。






 ![](https://c5.staticflickr.com/9/8450/28576673284_d764c1a76a_z.jpg)

#### 3. 页命中

如上图，当 CPU 读包含在 VP2 中的虚拟存储器的一个字时会怎样：

* 地址翻译硬件将虚拟地址作为一个索引来定位 PTE2，并从存储器中读取它
* 因为 有效位 = 0，地址翻译硬件知道 VP2 缓存在存储器中
* 使用 PTE 中的物理存储器地址（指向 PP1 中缓存页的起始位置），构造出这个字的物理地址

#### 4. 缺页

在虚拟存储器的习惯说法中：

* DRAM 缓存不命中称为 **缺页**（page fault）。
* 在磁盘和存储器之间传送页的活动叫做 **交换**（swapping）或者 **页面调度**（paging）。
* 页从磁盘 **换入**（或者页面调入）DRAM 和 从 DRAM 换出（或者页面调出）磁盘。
* 一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度（demand paging）。

 缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在 PP3 中的 VP4。如果VP4已经被修改了，那么内核就会将它拷贝回磁盘。无论哪种情况，内核都会修改 VP4 的页表条目，反映出 VP4 不再缓存在主存中这一事实。

接下来，内核从磁盘拷贝 VP3 到存储器中的 PP3，更新 PTE3，随后返回。

当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。

但是现在，VP3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。

![](https://c1.staticflickr.com/9/8277/29092063712_0a2812289f_b.jpg)

#### 5. 分配页面

 ![](https://c5.staticflickr.com/8/7723/28576673084_bef6def901_z.jpg)

### \# 虚拟存储器作为存储器管理的工具

实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。

 ![](https://c5.staticflickr.com/9/8221/29092063492_624bb0751d_z.jpg)

按需页面调度和独立的虚拟地址空间的结合，对系统中存储器的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。

* 简化链接

  > 独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。

   ![](https://c7.staticflickr.com/9/8482/28576672934_ae154bd818_b.jpg)

  ​

* 简化加载

  > 虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。

  > 将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作`存储器映射`（memory mapping）。Unix 提供了一个称为 mmap 的系统调用，允许应用程序自己做存储器映射。

* 简化共享

  > 操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个拷贝，而不是在每个进程中都包括单独的内核和 C 标准库的拷贝。

* 简化存储器分配

  > 当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），操作系统分配一个适当数字（例如 k）个连续的虚拟存储器页面，并且将它们映射到物理存储器中任意位置的 k 个任意的物理页面。页面可以随机地分散在物理存储器中。



### \# 虚拟存储器作为存储器保护的工具

任何现代计算机系统必须为操作系统提供手段来控制对存储器系统的访问。

* 不应该允许一个用户进程修改它的只读文本段
* 不应该允许它读或修改任何内核中的代码和数据结构
* 不应该允许它读或者写其他进程的私有存储器
* 不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显示地允许它这么做（通过调用明确的进程间通信系统调用）

通过在 PTE （Page Table Entry）上添加一些额外的许可位来控制对一个虚拟页面内容的访问：

- SUP位  表示进程是否必须运行在内核（超级用户）模式下才能访问该页
- READ 和 WRITE位  控制对页面的读和写访问

 ![](https://c5.staticflickr.com/9/8326/29092063132_bf6f5ae6a0_b.jpg)



如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Unix 外壳一般将这种异常报告为 **段错误** （segmentation  fault）。



### \# 地址翻译

本节将要使用的所有符号：

基本参数

| 符号      | 描述           |
| ------- | ------------ |
| N = 2^n | 虚拟地址空间中地址数量  |
| M = 2^m | 物理地址空间中的地址数量 |
| P = 2^p | 页的大小 (字节)    |



虚拟地址（VA）的组成部分

| 符号   | 描述          |
| ---- | ----------- |
| VPO  | 虚拟页面偏移量（字节） |
| VPN  | 虚拟页号        |
| TLBI | TLB 索引      |
| TLBT | TLB 标记      |



物理地址（PA）的组成部分

| 符号   | 描述          |
| ---- | ----------- |
| PPO  | 物理页面偏移量（字节） |
| PPN  | 物理页号        |
| CO   | 缓冲块内的字节偏移量  |
| CI   | 高速缓存索引      |
| CT   | 高速缓存标记      |



CPU 中的一个控制寄存器，**页表基址寄存器**（Page Table Base Register, PTBR）指向当前页表。

注意：

> 因为物理和虚拟页面都是 P 字节的，所以**物理页面偏移**（Physical Page Offset, PPO）和 VPO 是相同的。

 ![](https://c5.staticflickr.com/9/8834/28576672764_c89d22460c_b.jpg)







 ![](https://c1.staticflickr.com/9/8181/29092064992_c19da0fe10.jpg)

如果 TLB 有 T = 2^t 个组，那么 TLBI 是由 VPN（Virtual Page Number）的 t 个最低位组成的，而 TLB 标记（TLBT）是由 VPN 中剩余的位组成的。



![](https://c1.staticflickr.com/9/8285/28576673744_ffae73704a_b.jpg)

   ![](https://c5.staticflickr.com/9/8058/28576673684_336a033135_b.jpg)

### \# Intel Core i7/Linux 存储器系统

我们以一个实际系统的案例研究来概括我么对缓存和虚拟存储器的讨论：**一个运行 Linux 的 Intel Core i7**

#### Core i7 地址翻译

下图总结了完整的 Core i7 地址翻译过程，从 CPU 产生虚拟地址的时刻一直到来自存储器的数据字到达 CPU。

> Core i7 采用四级页表层次结构。
>
> 每个进程都有它自己私有的页表层次结构。
>
> CR3 控制寄存器指向第一级页表的起始位置。
>
> CR3 的值是每个进程上下文的一部分，每次上下文切换时，CR3的值都会被重置。

  ![](https://c1.staticflickr.com/9/8890/29092064312_58c7457275_b.jpg)

下图给出了 Core i7 MMU 如何使用四级的页表来将虚拟地址翻译成物理地址。

 ![](https://c7.staticflickr.com/9/8054/28576673534_81e290fb45_b.jpg)

#### Linux 虚拟存储器系统

对 Linux 的虚拟存储器系统做一个描述，大致了解一个实际的操作系统是如何组织虚拟存储器，以及如何处理缺页的。

Linux 为每个进程维持了一个单独的虚拟地址空间，如下图。

内核虚拟存储器的其他区域包含每个进程都不相同的数据；

> 例如，页表、内核在进程的上下文中执行代码时使用的栈
>
> **记录虚拟地址空间当前组织的各种数据结构**

 ![](https://c5.staticflickr.com/9/8192/29092064092_7a62abda95_z.jpg)

##### 1. Linux 虚拟存储器区域

Linux 将虚拟存储器组织成一些区域（也叫作段）的集合。

* 一个区域（area）就是已经存在着的（已分配的）虚拟存储器的连续片（chunk），这些页是以某种方式相关联的。

> 例如，代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。

* 每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。
* 区域的概念很重要，因为它允许虚拟地址空间有间隙。
* 内核不用记录那些不存在的虚拟页，而这样的页也不占用存储器、磁盘或者内核本身的任何额外资源。

内核为系统中的每个进程维护一个单独的任务结构（源代码中的 task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息:

> 例如，PID、指向用户栈的指针、可执行目标文件的名字以及程序计数器。

 

```c
~/include/linux/sched.h
struct task_struct {
	struct mm_struct *mm;
  	//...
};

------------------------------------------------------------------------------------------
~/include/linux/mm_types.h
struct mm_struct {
  	pgd_t  *pgd;
  	struct vm_area_struct  *mmap;
  	//...
};

struct vm_area_struct {
	unsigned long vm_start;
  	unsigned long vm_end;
  	
  	struct vm_area_struct *vm_next, *vm_prev;
  	pgprot_t  vm_page_prot;
  	unsigned long vm_flags;
};
```

![](https://c5.staticflickr.com/9/8193/28576673364_cf1ec2859f_b.jpg)

task_struct 中的一个条目指向 mm_struct，它描述了虚拟存储器的当前状态。

- pgd  指向第一级页表（页全局目录）的基址
- mmap 指向一个 vm_area_structs（区域结构）的链表

> 其中，每个 vm_area_structs 都描述了当前虚拟地址空间的一个区域（area）。
>
> 当内核运行这个进程时，它就将 pgd 存放在 CR3 控制寄存器中。

为了我们的目的，一个具体区域的区域结构包含下面的字段：

* vm_start：指向这个区域的起始处
* vm_end：指向这个区域的结束处
* vm_prot：描述这个区域内包含的所有页的读写许可权限
* vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的等
* vm_next：指向链表中下一个区域结构

##### 2. Linux 缺页异常处理

假设 MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后执行下面的步骤：

- 虚拟地址 A 是合法的吗？换句话说，A 在某个区域结构定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构的链表，把 A 和每个区域结构中的 vm_start 和 vm_end 做比较。如果这个指令是不合法的，那么缺页处理程序触发一个段错误，从而终止这个进程。

  > 因为一个进程可以创建任意数量的新虚拟存储器区域（使用 mmap 函数），所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux 使用某些我们没有显示出来的字段，Linux 在链表中构建了一棵树，并在这棵树上进行查找。

- 试图进行的存储器访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？

- 此刻，内核知道这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：

  > 选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。
  >
  > 当缺页处理程序返回时，CPU 重新启动引起缺页的指令，这条指令将再次发送 A 到 MMU。这次，MMU 就能正常翻译 A，而不会再产生缺页中断了。

   ![](https://c4.staticflickr.com/9/8502/29120680811_0fac3ab810_b.jpg)

  ​

### \# 存储器映射

Linux（以及其他一些形式的 Unix ）通过将一个虚拟存储器区域与一个磁盘上的**对象**（object）关联起来，以初始化这个虚拟存储器区域的内容，这个过程称为**存储器映射**（memory mapping）。虚拟存储器区域可以映射到两种类型的对象的一种：

* **Unix 文件系统中的普通文件**：

  > 一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。
  >
  > 文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际进入物理存储器，直到 CPU 第一次引用到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。

* **匿名文件**：

  >一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理存储器中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在存储器中的。注意在磁盘和存储器之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做**请求二进制零的页**（demand-zero page）。

无论在哪种情况下，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的**交换文件**（swap file）之间换来换去。交换文件也叫做**交换空间**（swap space）或者交换区域（swap area）。需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。



#### 再看共享对象

一个对象可以被映射到虚拟存储器的一个区域，要么作为**共享对象**，要么作为**私有对象**。

如果一个进程将一个**共享对象**映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何 **写操作**，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是 **可见的**。

而且，这些变化也会反映在磁盘上的原始对象中。

另一方面，对一个映射到**私有对象**的区域做的改变，对于其他进程来说是**不可见的**，并且进程对这个区域所做的任何**写操作**都不会反映在磁盘上的对象中。

一个映射到**共享对象**的虚拟存储器区域叫做**共享区域**。类似地，也有私有区域。

 ![](https://c3.staticflickr.com/9/8370/29092062922_dabb3b33a5_b.jpg)



 私有对象是使用一种叫做**写时拷贝**（copy-on-write）的巧妙技术被映射到虚拟存储器中的。

下图展示了一种情况：

- 两个进程将一个私有对象映射到它们虚拟存储器的不同区域，但是共享这个对象同一个物理拷贝。
- 对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为**私有的写时拷贝**。
- 只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。



![](https://c3.staticflickr.com/9/8314/28576672594_ef976c083d_b.jpg)



#### 再看 fork 函数

既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道 fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的。

当 fork 函数被**当前进程**调用时，内核为**新进程**创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct 、区域结构和页表的原样拷贝。

它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的**写时拷贝**。

当 fork 在新进程中返回时，新进程现在的虚拟存储器刚好和调用 fork 时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。



#### 再看 execve 函数

虚拟存储器和存储器映射在将程序加载到存储器的过程中扮演着关键的角色。既然已经理解了这些概念，我们就能够理解 **execve** 函数实际上是如何加载和执行程序的。

假设运行在当前进程中的程序执行了如下的调用：

```c
	Execve("a.out", NULL, NULL);	
```

execve 函数在当前进程中加载并运行包含在可执行目标文件 a.out 中的程序，用 a.out 程序有效地替代了当前程序。加载并运行 a.out 需要以下几个步骤：

* **删除已存在的用户区域**

  > 删除当前进程虚拟地址的用户部分中的已存在的区域结构。

* **映射私有区域**

  > 为新程序的文本、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时拷贝的。

   ![](https://c1.staticflickr.com/9/8034/29092062512_b4579b2bbe_b.jpg)

* **映射共享区域**

  > 如果 a.out 程序和共享对象（或目标）链接，比如标准 C 库 libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。

* **设置程序计数器**

  > execute 做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。

下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。



#### 使用 mmap 函数的用户级存储器映射

Unix 进程可以使用 mmap 函数来创建新的虚拟存储器区域，并将对象映射到这些区域中。

```c
#include <unistd.h>
#include <sys/mman.h>

/* 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。 */
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

mmap 函数要求内核创建一个新的虚拟存储器区域，最好是从地址 start 开始的一个区域，并将文件描述符 fd 指定的对象的一个连续的片（chunk）映射到这个新的区域。

 ![](https://c5.staticflickr.com/8/7795/28576672324_8b9a96416e_b.jpg)

参数 prot 包含了描述新映射的虚拟存储器区域的访问权限位（在相应区域结构中的 vm_prot 位）。

* PROT_EXEC	这个区域内的页面由可以被 CPU 执行的指令组成。
* PROT_READ    这个区域内的页面可读。
* PROT_WRITE    这个区域内的页面可写。
* PROT_NONE    这个区域内的页面不能被访问。

参数 flags 由描述被映射对象类型的位组成。如果设置了 MAP_ANON 标记位，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。MAP_PRIVATE 表示被映射的对象是一个私有的、写时拷贝的对象，而 MAP_SHARED 表示是一个共享对象。例如

```c
bufp = mmap(-1, size, PROT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);
```

让内核创建一个新的包含 size 字节的只读、私有、请求二进制零的虚拟存储器区域。如果调用成功，那么 bufp 包含新区域的地址。

munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域。接下来对已删除区域的引用会导致段错误。

```c
#include "csapp.h"

/*
 * mmapcopy - uses mmap to copy file fd to stdout
 */
void mmapcopy(int fd, int size)
{
	char *bufp; /* Pointer to memory mmaped VM area */
  	
  	bufp = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
  	Write(1, bufp, size);
  	return;
}

/* mmapcopy driver */
int main(int argc, char **argv)
{
	struct stat stat;
  	int fd;
  	
  	/* Check for required command line argument */
  	if (argc != 2) {
      	printf("usage: %s <filename>\n", argv[0]);
      	exit(0);
  	}
  
	/* Copy the input argument to stdout */
  	fd = Open(argv[1], O_RDONLY, 0);
  	fstat(fd, &stat);
  	mmapcopy(fd, stat.st_size);
  	exit(0);
}
```



### 动态存储器分配

虽然可以使用低级的 mmap 和 munmap 函数来创建和删除虚拟存储器的区域，但是 C 程序员还是会觉得当运行时需要额外虚拟存储器时，用 **动态存储器分配器** （dynamic memory allocator）更方便，也有更好的可移植性。

动态存储器分配器维护着一个进程的虚拟存储器区域，称为**堆**( heap )。系统之间细节不同，但是不失通用性，我们假设堆是一个请求二进制零的区域，它紧接在未初始化的 bss 区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量 brk （读作 "break"），它指向堆的顶部。

分配器有两种基本风格。两种风格都要求应用显示地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。

* 显示分配器（explicit allocator），要求应用显示地释放任何已分配的块。例如，C 程序通过调用 malloc 函数来分配一个块，并通过调用 free 函数来释放一个块。
* 隐式分配器（implicit allocator），隐式分配器也叫做 **垃圾收集器** (garbage collector)。



…… 待续



> **内容来自：<Computer Systems: A Programmer's Perspective>**

